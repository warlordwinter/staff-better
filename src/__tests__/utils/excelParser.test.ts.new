/**
 * @jest-environment node
 */
import { extractHeaders, extractDataWithHeaders } from "@/utils/excelParser";
import ExcelJS from "exceljs";

// Mock ExcelJS
jest.mock("exceljs", () => {
  return {
    Workbook: jest.fn().mockImplementation(() => ({
      worksheets: [],
      xlsx: {
        load: jest.fn(),
      },
    })),
    ValueType: {
      String: 1,
      Number: 2,
      Date: 3,
      Formula: 4,
    },
  };
});

describe("excelParser", () => {
  describe("extractHeaders", () => {
    describe("CSV files", () => {
      it("should extract headers from a simple CSV file", async () => {
        const csvContent = "Name,Phone,Email\n";
        const file = new File([csvContent], "test.csv", { type: "text/csv" });

        const headers = await extractHeaders(file);

        expect(headers).toEqual(["Name", "Phone", "Email"]);
      });
    });

    describe("XLSX files", () => {
      let mockWorkbook: any;
      let mockWorksheet: any;
      let mockRow: any;

      beforeEach(() => {
        mockRow = {
          eachCell: jest.fn((options, callback) => {
            // Handle both signatures: eachCell(callback) and eachCell(options, callback)
            const actualCallback = typeof options === 'function' ? options : callback;
            const cells = [
              { value: "Name" },
              { value: "Phone" },
              { value: "Email" },
            ];
            cells.forEach((cell, index) => {
              actualCallback(cell, index + 1);
            });
          }),
        };

        mockWorksheet = {
          getRow: jest.fn(() => mockRow),
        };

        mockWorkbook = {
          worksheets: [mockWorksheet],
          xlsx: {
            load: jest.fn().mockResolvedValue(undefined),
          },
        };

        (ExcelJS.Workbook as jest.Mock).mockImplementation(() => mockWorkbook);
      });

      it("should extract headers from an XLSX file", async () => {
        const buffer = new ArrayBuffer(8);
        const file = new File([buffer], "test.xlsx", {
          type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        });

        const headers = await extractHeaders(file);

        expect(headers).toEqual(["Name", "Phone", "Email"]);
        expect(ExcelJS.Workbook).toHaveBeenCalled();
        expect(mockWorkbook.xlsx.load).toHaveBeenCalledWith(buffer);
        expect(mockWorksheet.getRow).toHaveBeenCalledWith(1);
      });
    });

    describe("Error handling", () => {
      it("should throw error for unsupported file types", async () => {
        const file = new File(["content"], "test.txt", { type: "text/plain" });

        await expect(extractHeaders(file)).rejects.toThrow("Invalid file type");
      });
    });
  });

  describe("extractDataWithHeaders", () => {
    describe("CSV files", () => {
      it("should extract data with headers from a simple CSV file", async () => {
        const csvContent =
          "Name,Phone,Email\nJohn Doe,1234567890,john@example.com\nJane Smith,0987654321,jane@example.com\n";
        const file = new File([csvContent], "test.csv", {
          type: "text/csv",
        });

        const result = await extractDataWithHeaders(file);

        expect(result.headers).toEqual(["Name", "Phone", "Email"]);
        expect(result.rows).toHaveLength(2);
        expect(result.rows[0]).toEqual({
          Name: "John Doe",
          Phone: "1234567890",
          Email: "john@example.com",
        });
        expect(result.rows[1]).toEqual({
          Name: "Jane Smith",
          Phone: "0987654321",
          Email: "jane@example.com",
        });
      });

      it("should normalize phone numbers in CSV data", async () => {
        const csvContent =
          "Name,Phone Number,Email\nJohn Doe,(123) 456-7890,john@example.com\n";
        const file = new File([csvContent], "test.csv", {
          type: "text/csv",
        });

        const result = await extractDataWithHeaders(file);

        expect(result.rows[0]["Phone Number"]).toBe("1234567890");
      });
    });

    describe("XLSX files", () => {
      let mockWorkbook: any;
      let mockWorksheet: any;
      let mockHeaderRow: any;
      let mockDataRows: any[];

      beforeEach(() => {
        mockHeaderRow = {
          eachCell: jest.fn((options, callback) => {
            // Handle both signatures: eachCell(callback) and eachCell(options, callback)
            const actualCallback = typeof options === 'function' ? options : callback;
            const cells = [
              { value: "Name" },
              { value: "Phone" },
              { value: "Email" },
            ];
            cells.forEach((cell, index) => {
              actualCallback(cell, index + 1);
            });
          }),
        };

        mockDataRows = [
          {
            rowNumber: 1,
            eachCell: jest.fn(() => {
              // This is the header row, should be skipped
            }),
          },
          {
            rowNumber: 2,
            eachCell: jest.fn((options, callback) => {
              // Handle both signatures: eachCell(callback) and eachCell(options, callback)
              const actualCallback = typeof options === 'function' ? options : callback;
              const cells = [
                { value: "John Doe", type: 1 }, // ExcelJS.ValueType.String
                { value: 1234567890, type: 2 }, // ExcelJS.ValueType.Number
                { value: "john@example.com", type: 1 }, // ExcelJS.ValueType.String
              ];
              cells.forEach((cell, index) => {
                actualCallback(cell, index + 1);
              });
            }),
          },
          {
            rowNumber: 3,
            eachCell: jest.fn((options, callback) => {
              // Handle both signatures: eachCell(callback) and eachCell(options, callback)
              const actualCallback = typeof options === 'function' ? options : callback;
              const cells = [
                { value: "Jane Smith", type: 1 }, // ExcelJS.ValueType.String
                { value: 987654321, type: 2 }, // ExcelJS.ValueType.Number
                { value: "jane@example.com", type: 1 }, // ExcelJS.ValueType.String
              ];
              cells.forEach((cell, index) => {
                actualCallback(cell, index + 1);
              });
            }),
          },
        ];

        mockWorksheet = {
          getRow: jest.fn((rowNum) => {
            if (rowNum === 1) return mockHeaderRow;
            return mockDataRows[rowNum - 1];
          }),
          eachRow: jest.fn((callback) => {
            mockDataRows.forEach((row) => callback(row, row.rowNumber));
          }),
        };

        mockWorkbook = {
          worksheets: [mockWorksheet],
          xlsx: {
            load: jest.fn().mockResolvedValue(undefined),
          },
        };

        (ExcelJS.Workbook as jest.Mock).mockImplementation(() => mockWorkbook);
      });

      it("should extract data with headers from an XLSX file", async () => {
        const buffer = new ArrayBuffer(8);
        const file = new File([buffer], "test.xlsx", {
          type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        });

        const result = await extractDataWithHeaders(file);

        expect(result.headers).toEqual(["Name", "Phone", "Email"]);
        expect(result.rows).toHaveLength(2);
        expect(result.rows[0]).toEqual({
          Name: "John Doe",
          Phone: "1234567890",
          Email: "john@example.com",
        });
        expect(result.rows[1]).toEqual({
          Name: "Jane Smith",
          Phone: "987654321",
          Email: "jane@example.com",
        });
      });

      it("should handle empty cells in XLSX rows", async () => {
        mockDataRows[1].eachCell = jest.fn((options, callback) => {
          // Handle both signatures: eachCell(callback) and eachCell(options, callback)
          const actualCallback = typeof options === 'function' ? options : callback;
          const cells = [
            { value: "John Doe", type: 1 }, // ExcelJS.ValueType.String
            // Phone cell is empty
            { value: "john@example.com", type: 1 }, // ExcelJS.ValueType.String
          ];
          // Only call callback for non-empty cells
          actualCallback(cells[0], 1);
          if (cells[2]) actualCallback(cells[2], 3);
        });

        const buffer = new ArrayBuffer(8);
        const file = new File([buffer], "test.xlsx", {
          type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        });

        const result = await extractDataWithHeaders(file);

        expect(result.rows[0].Name).toBe("John Doe");
        expect(result.rows[0].Phone).toBe("");
        expect(result.rows[0].Email).toBe("john@example.com");
      });
    });

    describe("International phone numbers", () => {
      it("should reject international numbers with error", async () => {
        const csvContent =
          "Name,Phone,Email\nJohn Doe,+44 20 7946 0958,john@example.com\n";
        const file = new File([csvContent], "test.csv", {
          type: "text/csv",
        });

        await expect(extractDataWithHeaders(file)).rejects.toThrow(
          "International phone number not supported: +44 20 7946 0958"
        );
      });
    });

    describe("Error handling", () => {
      it("should throw error for unsupported file formats", async () => {
        const file = new File(["content"], "test.txt", { type: "text/plain" });

        await expect(extractDataWithHeaders(file)).rejects.toThrow(
          "Unsupported file format."
        );
      });
    });
  });
});