name: Deploy Lambda Function

on:
  push:
    paths:
      - "infrastructure/lambda/reminder-processor/**"
      - "infrastructure/lambda/daily-summary-email/**"
      - "infrastructure/cloudformation/**"
      - ".github/workflows/deploy-lambda.yml"
  workflow_dispatch: # Allows manual triggering

env:
  AWS_REGION: us-east-1
  STACK_NAME: reminder-scheduler-stack
  CLOUDFORMATION_TEMPLATE: infrastructure/cloudformation/reminder-scheduler-stack.yaml
  ROUTER_STACK_NAME: message-router-stack
  ROUTER_CLOUDFORMATION_TEMPLATE: infrastructure/cloudformation/message-router-stack.yaml

jobs:
  deploy-cloudformation:
    name: Deploy Reminder Scheduler Stack
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate required secrets
        run: |
          echo "Validating required GitHub secrets..."
          MISSING_SECRETS=()

          # Check if secrets are set (they'll be empty string if not set)
          # Using the actual secret names from the repository
          [ -z "${{ secrets.TWILIO_ACCOUNT_SID }}" ] && MISSING_SECRETS+=("TWILIO_ACCOUNT_SID")
          [ -z "${{ secrets.TWILIO_AUTH_TOKEN }}" ] && MISSING_SECRETS+=("TWILIO_AUTH_TOKEN")
          [ -z "${{ secrets.TWILIO_PHONE_NUMBER_REMINDERS }}" ] && MISSING_SECRETS+=("TWILIO_PHONE_NUMBER_REMINDERS")
          [ -z "${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}" ] && MISSING_SECRETS+=("NEXT_PUBLIC_SUPABASE_URL")
          [ -z "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ] && MISSING_SECRETS+=("SUPABASE_SERVICE_ROLE_KEY")
          [ -z "${{ secrets.SES_FROM_EMAIL }}" ] && MISSING_SECRETS+=("SES_FROM_EMAIL")
          [ -z "${{ secrets.API_BASE_URL }}" ] && MISSING_SECRETS+=("API_BASE_URL")
          [ -z "${{ secrets.CRON_SECRET }}" ] && MISSING_SECRETS+=("CRON_SECRET")

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "‚ùå Missing required GitHub secrets:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            echo ""
            echo "Please add these secrets in: Repository Settings ‚Üí Secrets and variables ‚Üí Actions"
            exit 1
          fi

          # Validate email format
          SES_EMAIL="${{ secrets.SES_FROM_EMAIL }}"
          if ! echo "$SES_EMAIL" | grep -qE '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'; then
            echo "‚ùå Invalid email format for SES_FROM_EMAIL: $SES_EMAIL"
            echo "Please provide a valid email address (e.g., noreply@yourdomain.com)"
            exit 1
          fi

          echo "‚úÖ All required secrets are set and valid"

      - name: Check if stack exists
        id: check-stack
        run: |
          if aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Stack exists, will update"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Stack does not exist, will create"
          fi

      - name: Deploy CloudFormation Stack (Create)
        id: create-stack
        if: steps.check-stack.outputs.exists == 'false'
        run: |
          echo "Creating CloudFormation stack..."
          echo "Note: If creation fails, the stack will be automatically deleted (--on-failure DELETE)"

          # Create stack with automatic deletion on failure
          aws cloudformation create-stack \
            --stack-name ${{ env.STACK_NAME }} \
            --template-body file://${{ env.CLOUDFORMATION_TEMPLATE }} \
            --parameters \
              ParameterKey=TwilioAccountSid,ParameterValue=${{ secrets.TWILIO_ACCOUNT_SID }} \
              ParameterKey=TwilioAuthToken,ParameterValue=${{ secrets.TWILIO_AUTH_TOKEN }} \
              ParameterKey=TwilioDefaultFrom,ParameterValue=${{ secrets.TWILIO_PHONE_NUMBER_REMINDERS }} \
              ParameterKey=SupabaseUrl,ParameterValue=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }} \
              ParameterKey=SupabaseServiceRoleKey,ParameterValue=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }} \
              ParameterKey=SesFromEmail,ParameterValue=${{ secrets.SES_FROM_EMAIL }} \
              ParameterKey=ApiBaseUrl,ParameterValue=${{ secrets.API_BASE_URL }} \
              ParameterKey=CronSecret,ParameterValue=${{ secrets.CRON_SECRET }} \
            --region ${{ env.AWS_REGION }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --on-failure DELETE

          echo "Waiting for stack creation to complete..."
          echo "If creation fails, CloudFormation will automatically delete the stack..."

          # Wait for stack creation, but handle failure gracefully
          if ! aws cloudformation wait stack-create-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} 2>&1; then
            
            echo "‚ùå Stack creation failed or timed out"
            echo "Checking if stack is being deleted..."
            
            # Check stack status
            STACK_STATUS=$(aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }} \
              --query 'Stacks[0].StackStatus' \
              --output text 2>/dev/null || echo "NOT_FOUND")
            
            echo "Current stack status: $STACK_STATUS"
            
            # If stack is being deleted or in failed state, wait for deletion
            if [ "$STACK_STATUS" = "DELETE_IN_PROGRESS" ] || [ "$STACK_STATUS" = "DELETE_COMPLETE" ]; then
              echo "Stack deletion in progress (triggered by --on-failure DELETE)..."
              aws cloudformation wait stack-delete-complete \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} || true
              echo "‚úÖ Failed stack has been automatically deleted"
            elif [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ]; then
              echo "Stack is in $STACK_STATUS state. Manually deleting..."
              aws cloudformation delete-stack \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }}
              aws cloudformation wait stack-delete-complete \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} || true
              echo "‚úÖ Failed stack has been deleted"
            fi
            
            exit 1
          fi

          echo "‚úÖ Stack created successfully"

      - name: Deploy CloudFormation Stack (Update)
        if: steps.check-stack.outputs.exists == 'true'
        timeout-minutes: 20
        run: |
          echo "Updating CloudFormation stack..."

          # Check current stack status
          echo "üìã Checking current stack status..."
          CURRENT_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null || echo "UNKNOWN")
          echo "   Current status: $CURRENT_STATUS"

          # Use 'deploy' command which handles "no updates" case gracefully
          echo "üöÄ Starting stack update (this may take 5-15 minutes)..."
          echo "   ‚è±Ô∏è  Timeout set to 20 minutes"
          echo "   üì¶ Stack: ${{ env.STACK_NAME }}"
          echo "   üåç Region: ${{ env.AWS_REGION }}"

          aws cloudformation deploy \
            --stack-name ${{ env.STACK_NAME }} \
            --template-file ${{ env.CLOUDFORMATION_TEMPLATE }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              TwilioAccountSid=${{ secrets.TWILIO_ACCOUNT_SID }} \
              TwilioAuthToken=${{ secrets.TWILIO_AUTH_TOKEN }} \
              TwilioDefaultFrom=${{ secrets.TWILIO_PHONE_NUMBER_REMINDERS }} \
              SupabaseUrl=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }} \
              SupabaseServiceRoleKey=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }} \
              SesFromEmail=${{ secrets.SES_FROM_EMAIL }} \
              ApiBaseUrl=${{ secrets.API_BASE_URL }} \
              CronSecret=${{ secrets.CRON_SECRET }} \
            --region ${{ env.AWS_REGION }} \
            --no-fail-on-empty-changeset || EXIT_CODE=$?

          # Exit code 255 means no updates are to be performed, which is OK
          if [ "${EXIT_CODE:-0}" = "255" ]; then
            echo "‚ÑπÔ∏è No stack updates detected - stack is already up to date"
          else
            echo "‚úÖ Stack updated successfully"
          fi

      - name: Get stack outputs
        if: success()
        run: |
          echo "üìã Stack Outputs:"
          aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs' \
            --output table

      - name: Cleanup failed stack
        if: failure() && steps.check-stack.outputs.exists == 'false'
        run: |
          echo "üßπ Cleaning up failed stack..."
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null || echo "NOT_FOUND")

          if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "ROLLBACK_IN_PROGRESS" ]; then
            echo "Stack is in $STACK_STATUS state. Deleting failed stack..."
            aws cloudformation delete-stack \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }}
            
            echo "Waiting for stack deletion to complete..."
            aws cloudformation wait stack-delete-complete \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }} || true
            echo "‚úÖ Failed stack has been deleted"
          else
            echo "Stack status: $STACK_STATUS - No cleanup needed"
          fi

  deploy-message-router-stack:
    name: Deploy Message Router Stack
    runs-on: ubuntu-latest
    needs: deploy-cloudformation
    if: always() && (needs.deploy-cloudformation.result == 'success' || needs.deploy-cloudformation.result == 'skipped')

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate required secrets for router stack
        run: |
          echo "Validating required GitHub secrets for Message Router stack..."
          MISSING_SECRETS=()

          # Check each secret (GitHub Actions will show empty string if not set)
          check_secret() {
            local secret_name=$1
            local secret_value="$2"
            if [ -z "$secret_value" ] || [ "$secret_value" = "" ]; then
              MISSING_SECRETS+=("$secret_name")
              echo "  ‚ùå $secret_name: NOT SET or EMPTY"
            else
              # Show first few chars for verification (but mask sensitive ones)
              if [[ "$secret_name" == *"PASSWORD"* ]] || [[ "$secret_name" == *"KEY"* ]] || [[ "$secret_name" == *"TOKEN"* ]]; then
                echo "  ‚úÖ $secret_name: SET (length: ${#secret_value} chars)"
              else
                echo "  ‚úÖ $secret_name: SET (value: ${secret_value:0:20}...)"
              fi
            fi
          }

          echo "Checking secrets..."
          check_secret "NEXT_PUBLIC_SUPABASE_URL" "${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}"
          check_secret "SUPABASE_SERVICE_ROLE_KEY" "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}"
          check_secret "JWT_VERIFICATION_KEY" "${{ secrets.JWT_VERIFICATION_KEY }}"
          check_secret "ROUTER_VPC_ID" "${{ secrets.ROUTER_VPC_ID }}"
          check_secret "ROUTER_PRIVATE_SUBNET_1_ID" "${{ secrets.ROUTER_PRIVATE_SUBNET_1_ID }}"
          check_secret "ROUTER_PRIVATE_SUBNET_2_ID" "${{ secrets.ROUTER_PRIVATE_SUBNET_2_ID }}"
          check_secret "ROUTER_PUBLIC_SUBNET_ID" "${{ secrets.ROUTER_PUBLIC_SUBNET_ID }}"
          check_secret "AMAZON_MQ_ADMIN_USER" "${{ secrets.AMAZON_MQ_ADMIN_USER }}"
          check_secret "AMAZON_MQ_ADMIN_PASSWORD" "${{ secrets.AMAZON_MQ_ADMIN_PASSWORD }}"

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå Missing or empty GitHub secrets for Message Router stack:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            echo ""
            echo "Please add these secrets in: Repository Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo ""
            echo "üìã How to find/create these values:"
            echo ""
            echo "VPC and Subnets (from AWS Console ‚Üí VPC):"
            echo "  - ROUTER_VPC_ID: VPC ID where Lambdas/Amazon MQ will run"
            echo "  - ROUTER_PRIVATE_SUBNET_1_ID: First private subnet ID"
            echo "  - ROUTER_PRIVATE_SUBNET_2_ID: Second private subnet ID (must be in different AZ)"
            echo ""
            echo "Amazon MQ Credentials (you'll create these):"
            echo "  - AMAZON_MQ_ADMIN_USER: Username for RabbitMQ broker (e.g., 'admin')"
            echo "  - AMAZON_MQ_ADMIN_PASSWORD: Password for RabbitMQ broker (strong password)"
            echo ""
            echo "JWT Verification:"
            echo "  - JWT_VERIFICATION_KEY: Supabase JWT public key or JWKS URL"
            echo "    Get from: Supabase Dashboard ‚Üí Project Settings ‚Üí API ‚Üí JWT Settings"
            exit 1
          fi

          echo ""
          echo "‚úÖ All required secrets are set and non-empty"

      - name: Check if router stack exists
        id: check-router-stack
        run: |
          if aws cloudformation describe-stacks \
            --stack-name ${{ env.ROUTER_STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Router stack exists, will update"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Router stack does not exist, will create"
          fi

      - name: Deploy Message Router CloudFormation Stack (Create)
        id: create-router-stack
        if: steps.check-router-stack.outputs.exists == 'false'
        run: |
          echo "Creating Message Router CloudFormation stack..."
          echo "Note: If creation fails, the stack will be automatically deleted (--on-failure DELETE)"

          # Verify secrets are still set (double-check before deploy)
          echo "Verifying secrets before deployment..."
          if [ -z "${{ secrets.ROUTER_VPC_ID }}" ]; then
            echo "‚ùå ERROR: ROUTER_VPC_ID is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.ROUTER_PRIVATE_SUBNET_1_ID }}" ]; then
            echo "‚ùå ERROR: ROUTER_PRIVATE_SUBNET_1_ID is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.ROUTER_PRIVATE_SUBNET_2_ID }}" ]; then
            echo "‚ùå ERROR: ROUTER_PRIVATE_SUBNET_2_ID is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.AMAZON_MQ_ADMIN_USER }}" ]; then
            echo "‚ùå ERROR: AMAZON_MQ_ADMIN_USER is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.AMAZON_MQ_ADMIN_PASSWORD }}" ]; then
            echo "‚ùå ERROR: AMAZON_MQ_ADMIN_PASSWORD is empty!"
            exit 1
          fi

          echo "‚úÖ All secrets verified, proceeding with deployment..."

          # Create stack with automatic deletion on failure
          aws cloudformation create-stack \
            --stack-name ${{ env.ROUTER_STACK_NAME }} \
            --template-body file://${{ env.ROUTER_CLOUDFORMATION_TEMPLATE }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameters \
              ParameterKey=SupabaseUrl,ParameterValue=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }} \
              ParameterKey=SupabaseServiceRoleKey,ParameterValue=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }} \
              ParameterKey=JwtVerificationKey,ParameterValue=${{ secrets.JWT_VERIFICATION_KEY }} \
              ParameterKey=VpcId,ParameterValue=${{ secrets.ROUTER_VPC_ID }} \
              ParameterKey=PrivateSubnet1Id,ParameterValue=${{ secrets.ROUTER_PRIVATE_SUBNET_1_ID }} \
              ParameterKey=PrivateSubnet2Id,ParameterValue=${{ secrets.ROUTER_PRIVATE_SUBNET_2_ID }} \
              ParameterKey=AmazonMqAdminUser,ParameterValue=${{ secrets.AMAZON_MQ_ADMIN_USER }} \
              ParameterKey=AmazonMqAdminPassword,ParameterValue=${{ secrets.AMAZON_MQ_ADMIN_PASSWORD }} \
            --region ${{ env.AWS_REGION }} \
            --on-failure DELETE

          echo "Waiting for stack creation to complete..."
          echo "If creation fails, CloudFormation will automatically delete the stack..."

          # Wait for stack creation, but handle failure gracefully
          if ! aws cloudformation wait stack-create-complete \
            --stack-name ${{ env.ROUTER_STACK_NAME }} \
            --region ${{ env.AWS_REGION }} 2>&1; then
            
            echo "‚ùå Stack creation failed or timed out"
            echo "Checking if stack is being deleted..."
            
            # Check stack status
            STACK_STATUS=$(aws cloudformation describe-stacks \
              --stack-name ${{ env.ROUTER_STACK_NAME }} \
              --region ${{ env.AWS_REGION }} \
              --query 'Stacks[0].StackStatus' \
              --output text 2>/dev/null || echo "NOT_FOUND")
            
            echo "Current stack status: $STACK_STATUS"
            
            # If stack is being deleted or in failed state, wait for deletion
            if [ "$STACK_STATUS" = "DELETE_IN_PROGRESS" ] || [ "$STACK_STATUS" = "DELETE_COMPLETE" ]; then
              echo "Stack deletion in progress (triggered by --on-failure DELETE)..."
              aws cloudformation wait stack-delete-complete \
                --stack-name ${{ env.ROUTER_STACK_NAME }} \
                --region ${{ env.AWS_REGION }} || true
              echo "‚úÖ Failed stack has been automatically deleted"
            elif [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ]; then
              echo "Stack is in $STACK_STATUS state. Manually deleting..."
              aws cloudformation delete-stack \
                --stack-name ${{ env.ROUTER_STACK_NAME }} \
                --region ${{ env.AWS_REGION }}
              aws cloudformation wait stack-delete-complete \
                --stack-name ${{ env.ROUTER_STACK_NAME }} \
                --region ${{ env.AWS_REGION }} || true
              echo "‚úÖ Failed stack has been deleted"
            fi
            
            exit 1
          fi

          echo "‚úÖ Stack created successfully"

      - name: Deploy Message Router CloudFormation Stack (Update)
        if: steps.check-router-stack.outputs.exists == 'true'
        timeout-minutes: 30
        run: |
          echo "Updating Message Router CloudFormation stack..."

          # Check current stack status
          echo "üìã Checking current stack status..."
          CURRENT_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.ROUTER_STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null || echo "UNKNOWN")
          echo "   Current status: $CURRENT_STATUS"

          # Deploy using command-line parameters (AWS CLI handles escaping)
          echo "üöÄ Starting stack update (this may take 10-25 minutes for message router stack)..."
          echo "   ‚è±Ô∏è  Timeout set to 30 minutes"
          echo "   üì¶ Stack: ${{ env.ROUTER_STACK_NAME }}"
          echo "   üåç Region: ${{ env.AWS_REGION }}"
          echo "   ‚ö†Ô∏è  Note: Message router stack includes Amazon MQ which can take longer to update"

          aws cloudformation deploy \
            --stack-name ${{ env.ROUTER_STACK_NAME }} \
            --template-file ${{ env.ROUTER_CLOUDFORMATION_TEMPLATE }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              "SupabaseUrl=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}" \
              "SupabaseServiceRoleKey=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
              "JwtVerificationKey=${{ secrets.JWT_VERIFICATION_KEY }}" \
              "VpcId=${{ secrets.ROUTER_VPC_ID }}" \
              "PrivateSubnet1Id=${{ secrets.ROUTER_PRIVATE_SUBNET_1_ID }}" \
              "PrivateSubnet2Id=${{ secrets.ROUTER_PRIVATE_SUBNET_2_ID }}" \
              "AmazonMqAdminUser=${{ secrets.AMAZON_MQ_ADMIN_USER }}" \
              "AmazonMqAdminPassword=${{ secrets.AMAZON_MQ_ADMIN_PASSWORD }}" \
            --region ${{ env.AWS_REGION }} \
            --no-fail-on-empty-changeset || EXIT_CODE=$?

          # Exit code 255 means no updates are to be performed, which is OK
          if [ "${EXIT_CODE:-0}" = "255" ]; then
            echo "‚ÑπÔ∏è No stack updates detected - stack is already up to date"
          else
            echo "‚úÖ Stack updated successfully"
          fi

      - name: Cleanup failed router stack
        if: failure() && steps.check-router-stack.outputs.exists == 'false'
        run: |
          echo "üßπ Cleaning up failed router stack..."
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.ROUTER_STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null || echo "NOT_FOUND")

          if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "ROLLBACK_IN_PROGRESS" ]; then
            echo "Stack is in $STACK_STATUS state. Deleting failed stack..."
            aws cloudformation delete-stack \
              --stack-name ${{ env.ROUTER_STACK_NAME }} \
              --region ${{ env.AWS_REGION }}
            
            echo "Waiting for stack deletion to complete..."
            aws cloudformation wait stack-delete-complete \
              --stack-name ${{ env.ROUTER_STACK_NAME }} \
              --region ${{ env.AWS_REGION }} || true
            echo "‚úÖ Failed stack has been deleted"
          else
            echo "Stack status: $STACK_STATUS - No cleanup needed"
          fi

      - name: Get Message Router stack outputs
        if: success()
        run: |
          echo "üìã Message Router Stack Outputs:"
          aws cloudformation describe-stacks \
            --stack-name ${{ env.ROUTER_STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs' \
            --output table

  deploy-reminder-processor:
    name: Deploy Reminder Processor Lambda
    runs-on: ubuntu-latest
    needs: [deploy-cloudformation, deploy-message-router-stack]
    env:
      LAMBDA_FUNCTION_NAME: ReminderProcessor
      LAMBDA_DIR: infrastructure/lambda/reminder-processor

    permissions:
      id-token: write # Required for OIDC
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: ${{ env.LAMBDA_DIR }}/package.json

      - name: Install Lambda dependencies
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          npm ci --omit=dev
          echo "Dependencies installed successfully"

      - name: Create deployment package
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          zip -r function.zip index.js node_modules/ -q
          echo "Package size: $(du -h function.zip | cut -f1)"

          # Check package size (Lambda limit is 50MB uncompressed)
          PACKAGE_SIZE=$(du -m function.zip | cut -f1)
          if [ $PACKAGE_SIZE -gt 45 ]; then
            echo "‚ö†Ô∏è Warning: Package size is ${PACKAGE_SIZE}MB, close to 50MB limit"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to Lambda
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          echo "Deploying Lambda function: ${{ env.LAMBDA_FUNCTION_NAME }}"
          aws lambda update-function-code \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --zip-file fileb://function.zip \
            --region ${{ env.AWS_REGION }}

          echo "‚úÖ Lambda function code updated successfully"

      - name: Wait for deployment to complete
        run: |
          echo "Waiting for Lambda deployment to complete..."
          aws lambda wait function-updated \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }}
          echo "‚úÖ Deployment completed"

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          LAST_MODIFIED=$(aws lambda get-function \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Configuration.LastModified' \
            --output text)

          echo "‚úÖ Lambda function last modified: $LAST_MODIFIED"

          # Get function version
          VERSION=$(aws lambda get-function \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Configuration.Version' \
            --output text)

          echo "üì¶ Function version: $VERSION"

      - name: Cleanup
        if: always()
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          rm -f function.zip
          echo "Cleaned up deployment package"

  deploy-daily-summary:
    name: Deploy Daily Summary Email Lambda
    runs-on: ubuntu-latest
    needs: [deploy-cloudformation, deploy-message-router-stack]
    env:
      LAMBDA_FUNCTION_NAME: DailySummaryEmail
      LAMBDA_DIR: infrastructure/lambda/daily-summary-email

    permissions:
      id-token: write # Required for OIDC
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: ${{ env.LAMBDA_DIR }}/package.json

      - name: Install Lambda dependencies
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          npm ci --omit=dev
          echo "Dependencies installed successfully"

      - name: Create deployment package
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          zip -r function.zip index.js emailTemplate.js node_modules/ -q
          echo "Package size: $(du -h function.zip | cut -f1)"

          # Check package size (Lambda limit is 50MB uncompressed)
          PACKAGE_SIZE=$(du -m function.zip | cut -f1)
          if [ $PACKAGE_SIZE -gt 45 ]; then
            echo "‚ö†Ô∏è Warning: Package size is ${PACKAGE_SIZE}MB, close to 50MB limit"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to Lambda
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          echo "Deploying Lambda function: ${{ env.LAMBDA_FUNCTION_NAME }}"
          aws lambda update-function-code \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --zip-file fileb://function.zip \
            --region ${{ env.AWS_REGION }}

          echo "‚úÖ Lambda function code updated successfully"

      - name: Wait for deployment to complete
        run: |
          echo "Waiting for Lambda deployment to complete..."
          aws lambda wait function-updated \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }}
          echo "‚úÖ Deployment completed"

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          LAST_MODIFIED=$(aws lambda get-function \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Configuration.LastModified' \
            --output text)

          echo "‚úÖ Lambda function last modified: $LAST_MODIFIED"

          # Get function version
          VERSION=$(aws lambda get-function \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Configuration.Version' \
            --output text)

          echo "üì¶ Function version: $VERSION"

      - name: Cleanup
        if: always()
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          rm -f function.zip
          echo "Cleaned up deployment package"

  deploy-message-router-lambdas:
    name: Deploy Message Router Lambdas
    runs-on: ubuntu-latest
    needs: deploy-message-router-stack
    env:
      ROUTER_LAMBDA_NAME: MessageRouter
      SEND_WORKER_LAMBDA_NAME: SendWorker
      REMINDER_WORKER_LAMBDA_NAME: ReminderWorker

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Message Router dependencies
        working-directory: infrastructure/lambda/message-router
        run: npm ci --omit=dev

      - name: Package Message Router Lambda
        working-directory: infrastructure/lambda/message-router
        run: zip -r function.zip index.js node_modules/ -q

      - name: Install Send Worker dependencies
        working-directory: infrastructure/lambda/send-worker
        run: npm ci --omit=dev

      - name: Package Send Worker Lambda
        working-directory: infrastructure/lambda/send-worker
        run: zip -r function.zip index.js node_modules/ -q

      - name: Install Reminder Worker dependencies
        working-directory: infrastructure/lambda/reminder-worker
        run: npm ci --omit=dev

      - name: Package Reminder Worker Lambda
        working-directory: infrastructure/lambda/reminder-worker
        run: zip -r function.zip index.js node_modules/ -q

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy Message Router Lambda
        working-directory: infrastructure/lambda/message-router
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.ROUTER_LAMBDA_NAME }} \
            --zip-file fileb://function.zip \
            --region ${{ env.AWS_REGION }}

      - name: Deploy Send Worker Lambda
        working-directory: infrastructure/lambda/send-worker
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.SEND_WORKER_LAMBDA_NAME }} \
            --zip-file fileb://function.zip \
            --region ${{ env.AWS_REGION }}

      - name: Deploy Reminder Worker Lambda
        working-directory: infrastructure/lambda/reminder-worker
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.REMINDER_WORKER_LAMBDA_NAME }} \
            --zip-file fileb://function.zip \
            --region ${{ env.AWS_REGION }}

      - name: Cleanup Message Router package
        if: always()
        working-directory: infrastructure/lambda/message-router
        run: rm -f function.zip

      - name: Cleanup Send Worker package
        if: always()
        working-directory: infrastructure/lambda/send-worker
        run: rm -f function.zip

      - name: Cleanup Reminder Worker package
        if: always()
        working-directory: infrastructure/lambda/reminder-worker
        run: rm -f function.zip
