name: Deploy Lambda Function

on:
  push:
    paths:
      - "infrastructure/lambda/reminder-processor/**"
      - "infrastructure/lambda/daily-summary-email/**"
      - "infrastructure/cloudformation/**"
      - ".github/workflows/deploy-lambda.yml"
  workflow_dispatch: # Allows manual triggering

env:
  AWS_REGION: us-east-1
  STACK_NAME: reminder-scheduler-stack
  CLOUDFORMATION_TEMPLATE: infrastructure/cloudformation/reminder-scheduler-stack.yaml
  ROUTER_STACK_NAME: message-router-stack
  ROUTER_CLOUDFORMATION_TEMPLATE: infrastructure/cloudformation/message-router-stack.yaml

jobs:
  deploy-cloudformation:
    name: Deploy Reminder Scheduler Stack
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate required secrets
        run: |
          echo "Validating required GitHub secrets..."
          MISSING_SECRETS=()

          # Check if secrets are set (they'll be empty string if not set)
          # Using the actual secret names from the repository
          [ -z "${{ secrets.TWILIO_ACCOUNT_SID }}" ] && MISSING_SECRETS+=("TWILIO_ACCOUNT_SID")
          [ -z "${{ secrets.TWILIO_AUTH_TOKEN }}" ] && MISSING_SECRETS+=("TWILIO_AUTH_TOKEN")
          [ -z "${{ secrets.TWILIO_PHONE_NUMBER_REMINDERS }}" ] && MISSING_SECRETS+=("TWILIO_PHONE_NUMBER_REMINDERS")
          [ -z "${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}" ] && MISSING_SECRETS+=("NEXT_PUBLIC_SUPABASE_URL")
          [ -z "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ] && MISSING_SECRETS+=("SUPABASE_SERVICE_ROLE_KEY")
          [ -z "${{ secrets.SES_FROM_EMAIL }}" ] && MISSING_SECRETS+=("SES_FROM_EMAIL")
          [ -z "${{ secrets.API_BASE_URL }}" ] && MISSING_SECRETS+=("API_BASE_URL")
          [ -z "${{ secrets.CRON_SECRET }}" ] && MISSING_SECRETS+=("CRON_SECRET")

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "‚ùå Missing required GitHub secrets:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            echo ""
            echo "Please add these secrets in: Repository Settings ‚Üí Secrets and variables ‚Üí Actions"
            exit 1
          fi

          # Validate email format
          SES_EMAIL="${{ secrets.SES_FROM_EMAIL }}"
          if ! echo "$SES_EMAIL" | grep -qE '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'; then
            echo "‚ùå Invalid email format for SES_FROM_EMAIL: $SES_EMAIL"
            echo "Please provide a valid email address (e.g., noreply@yourdomain.com)"
            exit 1
          fi

          echo "‚úÖ All required secrets are set and valid"

      - name: Check if stack exists
        id: check-stack
        run: |
          if aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Stack exists, will update"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Stack does not exist, will create"
          fi

      - name: Deploy CloudFormation Stack (Create)
        id: create-stack
        if: steps.check-stack.outputs.exists == 'false'
        run: |
          echo "Creating CloudFormation stack..."
          echo "Note: If creation fails, the stack will be automatically deleted (--on-failure DELETE)"

          # Create stack with automatic deletion on failure
          aws cloudformation create-stack \
            --stack-name ${{ env.STACK_NAME }} \
            --template-body file://${{ env.CLOUDFORMATION_TEMPLATE }} \
            --parameters \
              ParameterKey=TwilioAccountSid,ParameterValue=${{ secrets.TWILIO_ACCOUNT_SID }} \
              ParameterKey=TwilioAuthToken,ParameterValue=${{ secrets.TWILIO_AUTH_TOKEN }} \
              ParameterKey=TwilioDefaultFrom,ParameterValue=${{ secrets.TWILIO_PHONE_NUMBER_REMINDERS }} \
              ParameterKey=SupabaseUrl,ParameterValue=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }} \
              ParameterKey=SupabaseServiceRoleKey,ParameterValue=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }} \
              ParameterKey=SesFromEmail,ParameterValue=${{ secrets.SES_FROM_EMAIL }} \
              ParameterKey=ApiBaseUrl,ParameterValue=${{ secrets.API_BASE_URL }} \
              ParameterKey=CronSecret,ParameterValue=${{ secrets.CRON_SECRET }} \
            --region ${{ env.AWS_REGION }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --on-failure DELETE

          echo "Waiting for stack creation to complete..."
          echo "If creation fails, CloudFormation will automatically delete the stack..."

          # Wait for stack creation, but handle failure gracefully
          if ! aws cloudformation wait stack-create-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} 2>&1; then
            
            echo "‚ùå Stack creation failed or timed out"
            echo "Checking if stack is being deleted..."
            
            # Check stack status
            STACK_STATUS=$(aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }} \
              --query 'Stacks[0].StackStatus' \
              --output text 2>/dev/null || echo "NOT_FOUND")
            
            echo "Current stack status: $STACK_STATUS"
            
            # If stack is being deleted or in failed state, wait for deletion
            if [ "$STACK_STATUS" = "DELETE_IN_PROGRESS" ] || [ "$STACK_STATUS" = "DELETE_COMPLETE" ]; then
              echo "Stack deletion in progress (triggered by --on-failure DELETE)..."
              aws cloudformation wait stack-delete-complete \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} || true
              echo "‚úÖ Failed stack has been automatically deleted"
            elif [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ]; then
              echo "Stack is in $STACK_STATUS state. Manually deleting..."
              aws cloudformation delete-stack \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }}
              aws cloudformation wait stack-delete-complete \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} || true
              echo "‚úÖ Failed stack has been deleted"
            fi
            
            exit 1
          fi

          echo "‚úÖ Stack created successfully"

      - name: Deploy CloudFormation Stack (Update)
        if: steps.check-stack.outputs.exists == 'true'
        run: |
          echo "Updating CloudFormation stack..."
          # Use 'deploy' command which handles "no updates" case gracefully
          aws cloudformation deploy \
            --stack-name ${{ env.STACK_NAME }} \
            --template-file ${{ env.CLOUDFORMATION_TEMPLATE }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              TwilioAccountSid=${{ secrets.TWILIO_ACCOUNT_SID }} \
              TwilioAuthToken=${{ secrets.TWILIO_AUTH_TOKEN }} \
              TwilioDefaultFrom=${{ secrets.TWILIO_PHONE_NUMBER_REMINDERS }} \
              SupabaseUrl=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }} \
              SupabaseServiceRoleKey=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }} \
              SesFromEmail=${{ secrets.SES_FROM_EMAIL }} \
              ApiBaseUrl=${{ secrets.API_BASE_URL }} \
              CronSecret=${{ secrets.CRON_SECRET }} \
            --region ${{ env.AWS_REGION }} || EXIT_CODE=$?

          # Exit code 255 means no updates are to be performed, which is OK
          if [ "${EXIT_CODE:-0}" = "255" ]; then
            echo "‚ÑπÔ∏è No stack updates detected - stack is already up to date"
          else
            echo "‚úÖ Stack updated successfully"
          fi

      - name: Get stack outputs
        if: success()
        run: |
          echo "üìã Stack Outputs:"
          aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs' \
            --output table

      - name: Cleanup failed stack
        if: failure() && steps.check-stack.outputs.exists == 'false'
        run: |
          echo "üßπ Cleaning up failed stack..."
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null || echo "NOT_FOUND")

          if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "ROLLBACK_IN_PROGRESS" ]; then
            echo "Stack is in $STACK_STATUS state. Deleting failed stack..."
            aws cloudformation delete-stack \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }}
            
            echo "Waiting for stack deletion to complete..."
            aws cloudformation wait stack-delete-complete \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }} || true
            echo "‚úÖ Failed stack has been deleted"
          else
            echo "Stack status: $STACK_STATUS - No cleanup needed"
          fi

  deploy-message-router-stack:
    name: Deploy Message Router Stack
    runs-on: ubuntu-latest
    needs: deploy-cloudformation
    if: always() && (needs.deploy-cloudformation.result == 'success' || needs.deploy-cloudformation.result == 'skipped')

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy Message Router CloudFormation Stack
        run: |
          echo "Deploying Message Router CloudFormation stack..."
          aws cloudformation deploy \
            --stack-name ${{ env.ROUTER_STACK_NAME }} \
            --template-file ${{ env.ROUTER_CLOUDFORMATION_TEMPLATE }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              SupabaseUrl=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }} \
              SupabaseServiceRoleKey=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }} \
              JwtVerificationKey=${{ secrets.JWT_VERIFICATION_KEY }} \
              VpcId=${{ secrets.ROUTER_VPC_ID }} \
              PrivateSubnet1Id=${{ secrets.ROUTER_PRIVATE_SUBNET_1_ID }} \
              PrivateSubnet2Id=${{ secrets.ROUTER_PRIVATE_SUBNET_2_ID }} \
              AmazonMqAdminUser=${{ secrets.AMAZON_MQ_ADMIN_USER }} \
              AmazonMqAdminPassword=${{ secrets.AMAZON_MQ_ADMIN_PASSWORD }}

      - name: Get Message Router stack outputs
        if: success()
        run: |
          echo "üìã Message Router Stack Outputs:"
          aws cloudformation describe-stacks \
            --stack-name ${{ env.ROUTER_STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs' \
            --output table

  deploy-reminder-processor:
    name: Deploy Reminder Processor Lambda
    runs-on: ubuntu-latest
    needs: [deploy-cloudformation, deploy-message-router-stack]
    env:
      LAMBDA_FUNCTION_NAME: ReminderProcessor
      LAMBDA_DIR: infrastructure/lambda/reminder-processor

    permissions:
      id-token: write # Required for OIDC
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: ${{ env.LAMBDA_DIR }}/package.json

      - name: Install Lambda dependencies
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          npm ci --omit=dev
          echo "Dependencies installed successfully"

      - name: Create deployment package
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          zip -r function.zip index.js node_modules/ -q
          echo "Package size: $(du -h function.zip | cut -f1)"

          # Check package size (Lambda limit is 50MB uncompressed)
          PACKAGE_SIZE=$(du -m function.zip | cut -f1)
          if [ $PACKAGE_SIZE -gt 45 ]; then
            echo "‚ö†Ô∏è Warning: Package size is ${PACKAGE_SIZE}MB, close to 50MB limit"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to Lambda
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          echo "Deploying Lambda function: ${{ env.LAMBDA_FUNCTION_NAME }}"
          aws lambda update-function-code \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --zip-file fileb://function.zip \
            --region ${{ env.AWS_REGION }}

          echo "‚úÖ Lambda function code updated successfully"

      - name: Wait for deployment to complete
        run: |
          echo "Waiting for Lambda deployment to complete..."
          aws lambda wait function-updated \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }}
          echo "‚úÖ Deployment completed"

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          LAST_MODIFIED=$(aws lambda get-function \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Configuration.LastModified' \
            --output text)

          echo "‚úÖ Lambda function last modified: $LAST_MODIFIED"

          # Get function version
          VERSION=$(aws lambda get-function \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Configuration.Version' \
            --output text)

          echo "üì¶ Function version: $VERSION"

      - name: Cleanup
        if: always()
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          rm -f function.zip
          echo "Cleaned up deployment package"

  deploy-daily-summary:
    name: Deploy Daily Summary Email Lambda
    runs-on: ubuntu-latest
    needs: [deploy-cloudformation, deploy-message-router-stack]
    env:
      LAMBDA_FUNCTION_NAME: DailySummaryEmail
      LAMBDA_DIR: infrastructure/lambda/daily-summary-email

    permissions:
      id-token: write # Required for OIDC
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: ${{ env.LAMBDA_DIR }}/package.json

      - name: Install Lambda dependencies
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          npm ci --omit=dev
          echo "Dependencies installed successfully"

      - name: Create deployment package
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          zip -r function.zip index.js emailTemplate.js node_modules/ -q
          echo "Package size: $(du -h function.zip | cut -f1)"

          # Check package size (Lambda limit is 50MB uncompressed)
          PACKAGE_SIZE=$(du -m function.zip | cut -f1)
          if [ $PACKAGE_SIZE -gt 45 ]; then
            echo "‚ö†Ô∏è Warning: Package size is ${PACKAGE_SIZE}MB, close to 50MB limit"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to Lambda
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          echo "Deploying Lambda function: ${{ env.LAMBDA_FUNCTION_NAME }}"
          aws lambda update-function-code \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --zip-file fileb://function.zip \
            --region ${{ env.AWS_REGION }}

          echo "‚úÖ Lambda function code updated successfully"

      - name: Wait for deployment to complete
        run: |
          echo "Waiting for Lambda deployment to complete..."
          aws lambda wait function-updated \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }}
          echo "‚úÖ Deployment completed"

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          LAST_MODIFIED=$(aws lambda get-function \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Configuration.LastModified' \
            --output text)

          echo "‚úÖ Lambda function last modified: $LAST_MODIFIED"

          # Get function version
          VERSION=$(aws lambda get-function \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Configuration.Version' \
            --output text)

          echo "üì¶ Function version: $VERSION"

      - name: Cleanup
        if: always()
        working-directory: ${{ env.LAMBDA_DIR }}
        run: |
          rm -f function.zip
          echo "Cleaned up deployment package"

  deploy-message-router-lambdas:
    name: Deploy Message Router Lambdas
    runs-on: ubuntu-latest
    needs: deploy-message-router-stack
    env:
      ROUTER_LAMBDA_NAME: MessageRouter
      SEND_WORKER_LAMBDA_NAME: SendWorker
      REMINDER_WORKER_LAMBDA_NAME: ReminderWorker

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Message Router dependencies
        working-directory: infrastructure/lambda/message-router
        run: npm ci --omit=dev

      - name: Package Message Router Lambda
        working-directory: infrastructure/lambda/message-router
        run: zip -r function.zip index.js node_modules/ -q

      - name: Install Send Worker dependencies
        working-directory: infrastructure/lambda/send-worker
        run: npm ci --omit=dev

      - name: Package Send Worker Lambda
        working-directory: infrastructure/lambda/send-worker
        run: zip -r function.zip index.js node_modules/ -q

      - name: Install Reminder Worker dependencies
        working-directory: infrastructure/lambda/reminder-worker
        run: npm ci --omit=dev

      - name: Package Reminder Worker Lambda
        working-directory: infrastructure/lambda/reminder-worker
        run: zip -r function.zip index.js node_modules/ -q

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy Message Router Lambda
        working-directory: infrastructure/lambda/message-router
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.ROUTER_LAMBDA_NAME }} \
            --zip-file fileb://function.zip \
            --region ${{ env.AWS_REGION }}

      - name: Deploy Send Worker Lambda
        working-directory: infrastructure/lambda/send-worker
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.SEND_WORKER_LAMBDA_NAME }} \
            --zip-file fileb://function.zip \
            --region ${{ env.AWS_REGION }}

      - name: Deploy Reminder Worker Lambda
        working-directory: infrastructure/lambda/reminder-worker
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.REMINDER_WORKER_LAMBDA_NAME }} \
            --zip-file fileb://function.zip \
            --region ${{ env.AWS_REGION }}

      - name: Cleanup Message Router package
        if: always()
        working-directory: infrastructure/lambda/message-router
        run: rm -f function.zip

      - name: Cleanup Send Worker package
        if: always()
        working-directory: infrastructure/lambda/send-worker
        run: rm -f function.zip

      - name: Cleanup Reminder Worker package
        if: always()
        working-directory: infrastructure/lambda/reminder-worker
        run: rm -f function.zip
